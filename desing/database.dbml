Project gamus_core {
  database_type: 'sqlite'
  Note: 'Arquitectura Hexagonal Gamus: Schema verificado 1:1 con Domain Structs.'
}

// ==========================================
// 1. IDENTITY & ARTISTS
// ==========================================

Table artists {
  id uuid [pk]
  name text [not null]        // Rust: String
  bio text                    // Rust: Option<String> (nullable)
  created_at text [not null, default: `CURRENT_TIMESTAMP`]
  updated_at text [not null, default: `CURRENT_TIMESTAMP`]
}

Table artist_variations {
  id uuid [pk]
  artist_id uuid [not null, ref: > artists.id]
  variation text [not null]   // Rust: Vec<String> -> normalized
  
  indexes {
    (artist_id, variation) [unique]
  }
}

Table artist_sites {
  id uuid [pk]
  artist_id uuid [not null, ref: > artists.id]
  url text [not null]         // Rust: Vec<String> -> normalized
  
  indexes {
    (artist_id, url) [unique]
  }
}

// ==========================================
// 2. SONGS & STATS
// ==========================================

Table songs {
  id uuid [pk]
  title text [not null]       // Rust: String
  acoustid text               // Rust: Option<String> (nullable)
  created_at text [not null, default: `CURRENT_TIMESTAMP`]
  updated_at text [not null, default: `CURRENT_TIMESTAMP`]
}

// Domain: SongStats.comments
Table song_comments {
  id uuid [pk]
  song_id uuid [not null, ref: > songs.id]
  comment text [not null]
  created_at text [not null, default: `CURRENT_TIMESTAMP`]
}

// Domain: SongStats.avg_rating & ratings count
// Nota: Guardamos el valor interno (scaled u32) del struct Rating
Table song_ratings {
  id uuid [pk]
  song_id uuid [not null, ref: > songs.id]
  value_fixed_point int [not null] 
  created_at text [not null, default: `CURRENT_TIMESTAMP`]
}

// ==========================================
// 3. RELEASES (PRODUCT)
// ==========================================

Table releases {
  id uuid [pk]
  title text [not null]       // Rust: String
  release_date text           // Rust: Option<String>
  created_at text [not null, default: `CURRENT_TIMESTAMP`]
  updated_at text [not null, default: `CURRENT_TIMESTAMP`]
}

// Domain: Release.release_type (Vec<ReleaseType>)
Table release_types {
  id uuid [pk]
  release_id uuid [not null, ref: > releases.id]
  kind text [not null]        // String mapeado desde Enum o Custom
  
  indexes {
    (release_id, kind) [unique]
  }
}

// Domain: Release.main_artist_ids
Table release_main_artists {
  id uuid [pk]
  release_id uuid [not null, ref: > releases.id]
  artist_id uuid [not null, ref: > artists.id]
  
  indexes {
    (release_id, artist_id) [unique]
  }
}

// Domain: Release.genres (Vec<Genre>)
Table release_genres {
  id uuid [pk]
  release_id uuid [not null, ref: > releases.id]
  genre text [not null]
  
  indexes {
    (release_id, genre) [unique]
  }
}

// Domain: Release.styles (Vec<Style>)
Table release_styles {
  id uuid [pk]
  release_id uuid [not null, ref: > releases.id]
  style text [not null]
  
  indexes {
    (release_id, style) [unique]
  }
}

// Domain: Release.artworks (Vec<Artwork>)
Table artworks {
  id uuid [pk]
  release_id uuid [not null, ref: > releases.id]
  path text [not null]        // Rust: PathBuf -> String
  mime_type text [not null]   // Rust: String
  description text            // Rust: Option<String>
  hash text                   // Rust: String
  credits text                // Rust: Option<String>
  
  indexes {
    (release_id, path) [unique]
  }
}

// ==========================================
// 4. TRACKS (PHYSICAL INSTANCE)
// ==========================================

Table release_tracks {
  id uuid [pk]
  release_id uuid [not null, ref: > releases.id]
  song_id uuid [not null, ref: > songs.id]
  
  disc_number int [not null]   // Rust: u32
  track_number int [not null]  // Rust: u32
  title_override text          // Rust: Option<String>
  
  created_at text [not null, default: `CURRENT_TIMESTAMP`]
  updated_at text [not null, default: `CURRENT_TIMESTAMP`]
  
  indexes {
    (release_id, disc_number, track_number) [unique]
  }
}

// ==========================================
// 5. CREDITS (MUSICBRAINZ STYLE)
// ==========================================

Enum ArtistRole {
  Performer
  Featured
  Composer
  Producer
  Remixer
}

// Domain: ReleaseTrack.artist_credits
Table release_track_artists {
  id uuid [pk]
  release_track_id uuid [not null, ref: > release_tracks.id]
  artist_id uuid [not null, ref: > artists.id]
  role ArtistRole [not null]
  position int                // Rust: Option<u32>
  
  indexes {
    (release_track_id, artist_id, role) [unique]
  }
}

// ==========================================
// 6. FILES & TECHNICAL DETAILS
// ==========================================

// Flattening: FileDetails + AudioDetails + AudioAnalysis -> One Table
Table library_files {
  id uuid [pk]
  release_track_id uuid [not null, unique, ref: - release_tracks.id]
  
  // --- FileDetails ---
  path text [not null, unique]        // PathBuf -> String
  size_bytes bigint [not null]        // u64
  modified_unix bigint [not null]     // u64
  
  // --- AudioDetails ---
  duration_ms bigint [not null]       // Duration -> ms (u64/i64)
  bitrate_kbps int                    // Option<u32>
  sample_rate_hz int                  // Option<u32>
  channels int                        // Option<u8>
  fingerprint text                    // Option<String>
  
  // --- AudioAnalysis ---
  bpm real                            // Option<f32>
  
  // AudioQuality struct flattening
  quality_score real                  // AudioQuality.score (f32)
  quality_assessment text             // AudioQuality.assessment (String)
  
  // Features (Embedding)
  features blob                       // Option<Vec<f32>> serialized
  
  added_at text [not null, default: `CURRENT_TIMESTAMP`]
  updated_at text [not null, default: `CURRENT_TIMESTAMP`]
}